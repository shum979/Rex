// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package rex.core.xml


/**
  * usage:
  * val obj = scalaxb.fromXML[rex.core.xml.Foo](node)
  * val document = scalaxb.toXML[rex.core.xml.Foo](obj, "foo", rex.core.xml.defaultScope)
  **/
object `package` extends XMLProtocol {}

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  implicit lazy val executionContext = scala.concurrent.ExecutionContext.Implicits.global

  val defaultScope = scalaxb.toScope(Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val Rexcorexml_DataFlowsFormat: scalaxb.XMLFormat[rex.core.xml.DataFlows] = new DefaultRexcorexml_DataFlowsFormat {}
  implicit lazy val Rexcorexml_TypeFormat: scalaxb.XMLFormat[rex.core.xml.Type] = new DefaultRexcorexml_TypeFormat {}
  implicit lazy val Rexcorexml_FlowTypeFormat: scalaxb.XMLFormat[rex.core.xml.FlowType] = new DefaultRexcorexml_FlowTypeFormat {}
  implicit lazy val Rexcorexml_ExportFileTypeFormat: scalaxb.XMLFormat[rex.core.xml.ExportFileType] = new DefaultRexcorexml_ExportFileTypeFormat {}
  implicit lazy val Rexcorexml_AggregationsTypeFormat: scalaxb.XMLFormat[rex.core.xml.AggregationsType] = new DefaultRexcorexml_AggregationsTypeFormat {}
  implicit lazy val Rexcorexml_GroupByTypeFormat: scalaxb.XMLFormat[rex.core.xml.GroupByType] = new DefaultRexcorexml_GroupByTypeFormat {}
  implicit lazy val Rexcorexml_ColumnListTypeFormat: scalaxb.XMLFormat[rex.core.xml.ColumnListType] = new DefaultRexcorexml_ColumnListTypeFormat {}
  implicit lazy val Rexcorexml_SqlTypeFormat: scalaxb.XMLFormat[rex.core.xml.SqlType] = new DefaultRexcorexml_SqlTypeFormat {}
  implicit lazy val Rexcorexml_RenamesTypeFormat: scalaxb.XMLFormat[rex.core.xml.RenamesType] = new DefaultRexcorexml_RenamesTypeFormat {}
  implicit lazy val Rexcorexml_AddColumnsTypeFormat: scalaxb.XMLFormat[rex.core.xml.AddColumnsType] = new DefaultRexcorexml_AddColumnsTypeFormat {}
  implicit lazy val Rexcorexml_DeleteColumnTypeFormat: scalaxb.XMLFormat[rex.core.xml.DeleteColumnType] = new DefaultRexcorexml_DeleteColumnTypeFormat {}
  implicit lazy val Rexcorexml_AggregatorFormat: scalaxb.XMLFormat[rex.core.xml.Aggregator] = new DefaultRexcorexml_AggregatorFormat {}
  implicit lazy val Rexcorexml_AggregationTypeFormat: scalaxb.XMLFormat[rex.core.xml.AggregationType] = new DefaultRexcorexml_AggregationTypeFormat {}
  implicit lazy val Rexcorexml_RenameTypeFormat: scalaxb.XMLFormat[rex.core.xml.RenameType] = new DefaultRexcorexml_RenameTypeFormat {}
  implicit lazy val Rexcorexml_ValueFromFormat: scalaxb.XMLFormat[rex.core.xml.ValueFrom] = new DefaultRexcorexml_ValueFromFormat {}
  implicit lazy val Rexcorexml_AddColumnTypeFormat: scalaxb.XMLFormat[rex.core.xml.AddColumnType] = new DefaultRexcorexml_AddColumnTypeFormat {}
  implicit lazy val Rexcorexml_ColumnTransformationTypeFormat: scalaxb.XMLFormat[rex.core.xml.ColumnTransformationType] = new DefaultRexcorexml_ColumnTransformationTypeFormat {}
  implicit lazy val Rexcorexml_DataFlowTypeFormat: scalaxb.XMLFormat[rex.core.xml.DataFlowType] = new DefaultRexcorexml_DataFlowTypeFormat {}
  implicit lazy val Rexcorexml_TransformationsTypeFormat: scalaxb.XMLFormat[rex.core.xml.TransformationsType] = new DefaultRexcorexml_TransformationsTypeFormat {}
  implicit lazy val Rexcorexml_HiveTableTypeFormat: scalaxb.XMLFormat[rex.core.xml.HiveTableType] = new DefaultRexcorexml_HiveTableTypeFormat {}
  implicit lazy val Rexcorexml_TransCategoryFormat: scalaxb.XMLFormat[rex.core.xml.TransCategory] = new DefaultRexcorexml_TransCategoryFormat {}
  implicit lazy val Rexcorexml_ExpressionFormat: scalaxb.XMLFormat[rex.core.xml.Expression] = new DefaultRexcorexml_ExpressionFormat {}
  implicit lazy val Rexcorexml_TransformationTypeFormat: scalaxb.XMLFormat[rex.core.xml.TransformationType] = new DefaultRexcorexml_TransformationTypeFormat {}
  implicit lazy val Rexcorexml_ModeTypeFormat: scalaxb.XMLFormat[rex.core.xml.ModeType] = new DefaultRexcorexml_ModeTypeFormat {}
  implicit lazy val Rexcorexml_DataSourcesTypeFormat: scalaxb.XMLFormat[rex.core.xml.DataSourcesType] = new DefaultRexcorexml_DataSourcesTypeFormat {}
  implicit lazy val Rexcorexml_DataSourceTypeFormat: scalaxb.XMLFormat[rex.core.xml.DataSourceType] = new DefaultRexcorexml_DataSourceTypeFormat {}
  implicit lazy val Rexcorexml_DatabaseTypeFormat: scalaxb.XMLFormat[rex.core.xml.DatabaseType] = new DefaultRexcorexml_DatabaseTypeFormat {}
  implicit lazy val Rexcorexml_FormatFormat: scalaxb.XMLFormat[rex.core.xml.Format] = new DefaultRexcorexml_FormatFormat {}
  implicit lazy val Rexcorexml_FileTypeFormat: scalaxb.XMLFormat[rex.core.xml.FileType] = new DefaultRexcorexml_FileTypeFormat {}
  implicit lazy val Rexcorexml_WithColumnTypeFormat: scalaxb.XMLFormat[rex.core.xml.WithColumnType] = new DefaultRexcorexml_WithColumnTypeFormat {}
  implicit lazy val Rexcorexml_PropertiesTypeFormat: scalaxb.XMLFormat[rex.core.xml.PropertiesType] = new DefaultRexcorexml_PropertiesTypeFormat {}
  implicit lazy val Rexcorexml_PropertyFilePathTypeFormat: scalaxb.XMLFormat[rex.core.xml.PropertyFilePathType] = new DefaultRexcorexml_PropertyFilePathTypeFormat {}
  implicit lazy val Rexcorexml_PropertyTypeFormat: scalaxb.XMLFormat[rex.core.xml.PropertyType] = new DefaultRexcorexml_PropertyTypeFormat {}
  implicit lazy val Rexcorexml_IngestTypeFormat: scalaxb.XMLFormat[rex.core.xml.IngestType] = new DefaultRexcorexml_IngestTypeFormat {}
  implicit lazy val Rexcorexml_SourceTypeFormat: scalaxb.XMLFormat[rex.core.xml.SourceType] = new DefaultRexcorexml_SourceTypeFormat {}
  implicit lazy val Rexcorexml_ReportingSqlFormat: scalaxb.XMLFormat[rex.core.xml.ReportingSql] = new DefaultRexcorexml_ReportingSqlFormat {}
  implicit lazy val Rexcorexml_ReportingTypeFormat: scalaxb.XMLFormat[rex.core.xml.ReportingType] = new DefaultRexcorexml_ReportingTypeFormat {}
  implicit lazy val Rexcorexml_SideFormat: scalaxb.XMLFormat[rex.core.xml.Side] = new DefaultRexcorexml_SideFormat {}
  implicit lazy val Rexcorexml_StrategyFormat: scalaxb.XMLFormat[rex.core.xml.Strategy] = new DefaultRexcorexml_StrategyFormat {}
  implicit lazy val Rexcorexml_DeDuplicationTypeFormat: scalaxb.XMLFormat[rex.core.xml.DeDuplicationType] = new DefaultRexcorexml_DeDuplicationTypeFormat {}
  implicit lazy val Rexcorexml_DateColumnFormat: scalaxb.XMLFormat[rex.core.xml.DateColumn] = new DefaultRexcorexml_DateColumnFormat {}
  implicit lazy val Rexcorexml_DateColumnsTypeFormat: scalaxb.XMLFormat[rex.core.xml.DateColumnsType] = new DefaultRexcorexml_DateColumnsTypeFormat {}
  implicit lazy val Rexcorexml_ModeFormat: scalaxb.XMLFormat[rex.core.xml.Mode] = new DefaultRexcorexml_ModeFormat {}
  implicit lazy val Rexcorexml_SelectColumnsWithModeTypeFormat: scalaxb.XMLFormat[rex.core.xml.SelectColumnsWithModeType] = new DefaultRexcorexml_SelectColumnsWithModeTypeFormat {}
  implicit lazy val Rexcorexml_ReconcilerTypeFormat: scalaxb.XMLFormat[rex.core.xml.ReconcilerType] = new DefaultRexcorexml_ReconcilerTypeFormat {}
  implicit lazy val Rexcorexml_ReconciliationTypeFormat: scalaxb.XMLFormat[rex.core.xml.ReconciliationType] = new DefaultRexcorexml_ReconciliationTypeFormat {}
  implicit lazy val Rexcorexml_ExportTypeFormat: scalaxb.XMLFormat[rex.core.xml.ExportType] = new DefaultRexcorexml_ExportTypeFormat {}
  implicit lazy val Rexcorexml_AdditionalFieldsTypeFormat: scalaxb.XMLFormat[rex.core.xml.AdditionalFieldsType] = new DefaultRexcorexml_AdditionalFieldsTypeFormat {}
  implicit lazy val Rexcorexml_ColumnFormat: scalaxb.XMLFormat[rex.core.xml.Column] = new DefaultRexcorexml_ColumnFormat {}
  implicit lazy val Rexcorexml_ExpressionColumnTypeFormat: scalaxb.XMLFormat[rex.core.xml.ExpressionColumnType] = new DefaultRexcorexml_ExpressionColumnTypeFormat {}
  implicit lazy val Rexcorexml_Column2Format: scalaxb.XMLFormat[rex.core.xml.Column2] = new DefaultRexcorexml_Column2Format {}
  implicit lazy val Rexcorexml_ExpressionRowTypeFormat: scalaxb.XMLFormat[rex.core.xml.ExpressionRowType] = new DefaultRexcorexml_ExpressionRowTypeFormat {}
  implicit lazy val Rexcorexml_ExpressionFilterTypeFormat: scalaxb.XMLFormat[rex.core.xml.ExpressionFilterType] = new DefaultRexcorexml_ExpressionFilterTypeFormat {}
  implicit lazy val Rexcorexml_SchemaColumnTypeFormat: scalaxb.XMLFormat[rex.core.xml.SchemaColumnType] = new DefaultRexcorexml_SchemaColumnTypeFormat {}
  implicit lazy val Rexcorexml_EnforceModeFormat: scalaxb.XMLFormat[rex.core.xml.EnforceMode] = new DefaultRexcorexml_EnforceModeFormat {}
  implicit lazy val Rexcorexml_SchemaTypeFormat: scalaxb.XMLFormat[rex.core.xml.SchemaType] = new DefaultRexcorexml_SchemaTypeFormat {}
  implicit lazy val Rexcorexml_JoinTypeFormat: scalaxb.XMLFormat[rex.core.xml.JoinType] = new DefaultRexcorexml_JoinTypeFormat {}
  implicit lazy val Rexcorexml_JoinKeyFormat: scalaxb.XMLFormat[rex.core.xml.JoinKey] = new DefaultRexcorexml_JoinKeyFormat {}
  implicit lazy val Rexcorexml_JoinTransformTypeFormat: scalaxb.XMLFormat[rex.core.xml.JoinTransformType] = new DefaultRexcorexml_JoinTransformTypeFormat {}
  implicit lazy val Rexcorexml_ColumnDataTypeFormat: scalaxb.XMLFormat[rex.core.xml.ColumnDataType] = new DefaultRexcorexml_ColumnDataTypeFormat {}
  implicit lazy val Rexcorexml_ExportFormatFormat: scalaxb.XMLFormat[rex.core.xml.ExportFormat] = new DefaultRexcorexml_ExportFormatFormat {}
  implicit lazy val Rexcorexml_PartitionTypeFormat: scalaxb.XMLFormat[rex.core.xml.PartitionType] = new DefaultRexcorexml_PartitionTypeFormat {}


  implicit val fromAnySchemaType: scala.xml.Elem => Option[scalaxb.DataRecord[Any]] = { elem =>
    import scalaxb.{DataRecord, Helper, fromXML}

    val ns = Helper.nullOrEmpty(elem.scope.getURI(elem.prefix))
    val key = Some(elem.label)
    val (xsns, xstype) = Helper.instanceType(elem)

    (key, ns) match {
      case (Some("DataFlows"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[rex.core.xml.DataFlows](elem)))

      case _ => None
    }
  }

  def buildRexcorexml_TypeFormat = new DefaultRexcorexml_TypeFormat {}

  def buildRexcorexml_AggregatorFormat = new DefaultRexcorexml_AggregatorFormat {}

  def buildRexcorexml_ValueFromFormat = new DefaultRexcorexml_ValueFromFormat {}

  def buildRexcorexml_TransCategoryFormat = new DefaultRexcorexml_TransCategoryFormat {}

  def buildRexcorexml_ModeTypeFormat = new DefaultRexcorexml_ModeTypeFormat {}

  def buildRexcorexml_FormatFormat = new DefaultRexcorexml_FormatFormat {}

  def buildRexcorexml_SourceTypeFormat = new DefaultRexcorexml_SourceTypeFormat {}

  def buildRexcorexml_SideFormat = new DefaultRexcorexml_SideFormat {}

  def buildRexcorexml_ModeFormat = new DefaultRexcorexml_ModeFormat {}

  def buildRexcorexml_EnforceModeFormat = new DefaultRexcorexml_EnforceModeFormat {}

  def buildRexcorexml_JoinTypeFormat = new DefaultRexcorexml_JoinTypeFormat {}

  def buildRexcorexml_ColumnDataTypeFormat = new DefaultRexcorexml_ColumnDataTypeFormat {}

  def buildRexcorexml_ExportFormatFormat = new DefaultRexcorexml_ExportFormatFormat {}

  trait DefaultRexcorexml_DataFlowsFormat extends scalaxb.ElemNameParser[rex.core.xml.DataFlows] {
    val targetNamespace: Option[String] = None

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.DataFlows] =
      phrase(opt(scalaxb.ElemName(None, "DataSources")) ~
        opt(scalaxb.ElemName(None, "Properties")) ~
        safeRep(scalaxb.ElemName(None, "DataFlow")) ^^ { case p1 ~ p2 ~ p3 =>
        rex.core.xml.DataFlows(p1.headOption map {
          scalaxb.fromXML[rex.core.xml.DataSourcesType](_, scalaxb.ElemName(node) :: stack)
        },
          p2.headOption map {
            scalaxb.fromXML[rex.core.xml.PropertiesType](_, scalaxb.ElemName(node) :: stack)
          },
          p3 map {
            scalaxb.fromXML[rex.core.xml.DataFlowType](_, scalaxb.ElemName(node) :: stack)
          },
          scala.collection.immutable.ListMap(List(
            (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@name" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.DataFlows, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.DataFlows, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.DataSources map {
        scalaxb.toXML[rex.core.xml.DataSourcesType](_, None, Some("DataSources"), __scope, false)
      } getOrElse {
        Nil
      },
        __obj.Properties map {
          scalaxb.toXML[rex.core.xml.PropertiesType](_, None, Some("Properties"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.DataFlow flatMap {
          scalaxb.toXML[rex.core.xml.DataFlowType](_, None, Some("DataFlow"), __scope, false) })

  }

  trait DefaultRexcorexml_TypeFormat extends scalaxb.XMLFormat[rex.core.xml.Type] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.Type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.Type = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Transform")) => rex.core.xml.Transform
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("SQL")) => rex.core.xml.SQL
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Export")) => rex.core.xml.Export
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Ingest")) => rex.core.xml.Ingest
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Reporting")) => rex.core.xml.Reporting
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Reconcile")) => rex.core.xml.Reconcile

    }

    def writes(__obj: rex.core.xml.Type, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultRexcorexml_FlowTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.FlowType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("FlowType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.FlowType] =
      phrase(opt(scalaxb.ElemName(None, "Ingest")) ~
        opt(scalaxb.ElemName(None, "Transformations")) ~
        opt(scalaxb.ElemName(None, "Sql")) ~
        opt(scalaxb.ElemName(None, "Export")) ~
        opt(scalaxb.ElemName(None, "Reporting")) ~
        opt(scalaxb.ElemName(None, "Reconciliation")) ^^ { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
        rex.core.xml.FlowType(p1.headOption map {
          scalaxb.fromXML[rex.core.xml.IngestType](_, scalaxb.ElemName(node) :: stack)
        },
          p2.headOption map {
            scalaxb.fromXML[rex.core.xml.TransformationsType](_, scalaxb.ElemName(node) :: stack)
          },
          p3.headOption map {
            scalaxb.fromXML[rex.core.xml.SqlType](_, scalaxb.ElemName(node) :: stack)
          },
          p4.headOption map {
            scalaxb.fromXML[rex.core.xml.ExportType](_, scalaxb.ElemName(node) :: stack)
          },
          p5.headOption map {
            scalaxb.fromXML[rex.core.xml.ReportingType](_, scalaxb.ElemName(node) :: stack)
          },
          p6.headOption map {
            scalaxb.fromXML[rex.core.xml.ReconciliationType](_, scalaxb.ElemName(node) :: stack)
          },
          scala.collection.immutable.ListMap(List(
            (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@id" -> _
            },
            (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.Type](x, scalaxb.ElemName(node) :: stack)) } map {
              "@type" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.FlowType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.FlowType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.Ingest map {
        scalaxb.toXML[rex.core.xml.IngestType](_, None, Some("Ingest"), __scope, false)
      } getOrElse {
        Nil
      },
        __obj.Transformations map {
          scalaxb.toXML[rex.core.xml.TransformationsType](_, None, Some("Transformations"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Sql map {
          scalaxb.toXML[rex.core.xml.SqlType](_, None, Some("Sql"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Export map {
          scalaxb.toXML[rex.core.xml.ExportType](_, None, Some("Export"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Reporting map {
          scalaxb.toXML[rex.core.xml.ReportingType](_, None, Some("Reporting"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Reconciliation map {
          scalaxb.toXML[rex.core.xml.ReconciliationType](_, None, Some("Reconciliation"), __scope, false)
        } getOrElse {
          Nil})

  }

  trait DefaultRexcorexml_ExportFileTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.ExportFileType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("ExportFileType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.ExportFileType] =
      phrase((scalaxb.ElemName(None, "TargetStore")) ~
        (scalaxb.ElemName(None, "FileLocation")) ~
        opt(scalaxb.ElemName(None, "Partition")) ~
        opt(scalaxb.ElemName(None, "Mode")) ~
        opt(scalaxb.ElemName(None, "Delimiter")) ~
        opt(scalaxb.ElemName(None, "IncludeHeader")) ^^ { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
        rex.core.xml.ExportFileType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
          scalaxb.fromXML[String](p2, scalaxb.ElemName(node) :: stack),
          p3.headOption map {
            scalaxb.fromXML[rex.core.xml.PartitionType](_, scalaxb.ElemName(node) :: stack)
          },
          p4.headOption map {
            scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
          },
          p5.headOption map {
            scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
          },
          p6.headOption map {
            scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack)
          },
          scala.collection.immutable.ListMap(List(
            (node \ "@format").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.ExportFormat](x, scalaxb.ElemName(node) :: stack)) } map {
              "@format" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.ExportFileType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@format", _) => attr = scala.xml.Attribute(null, "format", __obj.format.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.ExportFileType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.TargetStore, None, Some("TargetStore"), __scope, false),
        scalaxb.toXML[String](__obj.FileLocation, None, Some("FileLocation"), __scope, false),
        __obj.Partition map {
          scalaxb.toXML[rex.core.xml.PartitionType](_, None, Some("Partition"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Mode map {
          scalaxb.toXML[String](_, None, Some("Mode"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Delimiter map {
          scalaxb.toXML[String](_, None, Some("Delimiter"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.IncludeHeader map {
          scalaxb.toXML[Boolean](_, None, Some("IncludeHeader"), __scope, false)
        } getOrElse {
          Nil})

  }

  trait DefaultRexcorexml_AggregationsTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.AggregationsType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("AggregationsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.AggregationsType] =
      phrase(safeRep(scalaxb.ElemName(None, "Aggregation")) ^^ { case p1 =>
        rex.core.xml.AggregationsType(p1 map {
          scalaxb.fromXML[rex.core.xml.AggregationType](_, scalaxb.ElemName(node) :: stack)
        }) })

    def writesChildNodes(__obj: rex.core.xml.AggregationsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Aggregation flatMap {
        scalaxb.toXML[rex.core.xml.AggregationType](_, None, Some("Aggregation"), __scope, false) })
  }

  trait DefaultRexcorexml_GroupByTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.GroupByType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("GroupByType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.GroupByType] =
      phrase(safeRep(scalaxb.ElemName(None, "GroupByColumn")) ~
        safeRep(scalaxb.ElemName(None, "AggregateColumn")) ^^ { case p1 ~ p2 =>
        rex.core.xml.GroupByType(p1 map {
          scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
        },
          p2 map {
            scalaxb.fromXML[rex.core.xml.AggregationType](_, scalaxb.ElemName(node) :: stack)
          }) })

    def writesChildNodes(__obj: rex.core.xml.GroupByType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.GroupByColumn flatMap {
        scalaxb.toXML[String](_, None, Some("GroupByColumn"), __scope, false)
      },
        __obj.AggregateColumn flatMap {
          scalaxb.toXML[rex.core.xml.AggregationType](_, None, Some("AggregateColumn"), __scope, false) })

  }

  trait DefaultRexcorexml_ColumnListTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.ColumnListType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("ColumnListType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.ColumnListType] =
      phrase(safeRep(scalaxb.ElemName(None, "Column")) ^^ { case p1 =>
        rex.core.xml.ColumnListType(p1 map {
          scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
        }) })

    def writesChildNodes(__obj: rex.core.xml.ColumnListType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Column flatMap {
        scalaxb.toXML[String](_, None, Some("Column"), __scope, false) })
  }

  trait DefaultRexcorexml_SqlTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.SqlType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("SqlType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.SqlType] =
      phrase((scalaxb.ElemName(None, "Query")) ^^ { case p1 =>
        rex.core.xml.SqlType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
          scala.collection.immutable.ListMap(List(
            (node \ "@registerAsTempTable").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map {
              "@registerAsTempTable" -> _
            },
            (node \ "@applyondataref").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@applyondataref" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.SqlType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@registerAsTempTable", _) => __obj.registerAsTempTable foreach { x => attr = scala.xml.Attribute(null, "registerAsTempTable", x.toString, attr) }
        case ("@applyondataref", _) => attr = scala.xml.Attribute(null, "applyondataref", __obj.applyondataref.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.SqlType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[String](__obj.Query, None, Some("Query"), __scope, false))
  }

  trait DefaultRexcorexml_RenamesTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.RenamesType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("RenamesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.RenamesType] =
      phrase(safeRep(scalaxb.ElemName(None, "Column")) ^^ { case p1 =>
        rex.core.xml.RenamesType(p1 map {
          scalaxb.fromXML[rex.core.xml.RenameType](_, scalaxb.ElemName(node) :: stack)
        }) })

    def writesChildNodes(__obj: rex.core.xml.RenamesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Column flatMap {
        scalaxb.toXML[rex.core.xml.RenameType](_, None, Some("Column"), __scope, false) })
  }

  trait DefaultRexcorexml_AddColumnsTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.AddColumnsType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("AddColumnsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.AddColumnsType] =
      phrase(safeRep(scalaxb.ElemName(None, "Column")) ^^ { case p1 =>
        rex.core.xml.AddColumnsType(p1 map {
          scalaxb.fromXML[rex.core.xml.AddColumnType](_, scalaxb.ElemName(node) :: stack)
        }) })

    def writesChildNodes(__obj: rex.core.xml.AddColumnsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Column flatMap {
        scalaxb.toXML[rex.core.xml.AddColumnType](_, None, Some("Column"), __scope, false) })
  }

  trait DefaultRexcorexml_DeleteColumnTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.DeleteColumnType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("DeleteColumnType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.DeleteColumnType] =
      phrase(safeRep(scalaxb.ElemName(None, "Column")) ^^ { case p1 =>
        rex.core.xml.DeleteColumnType(p1 map {
          scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
        }) })

    def writesChildNodes(__obj: rex.core.xml.DeleteColumnType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Column flatMap {
        scalaxb.toXML[String](_, None, Some("Column"), __scope, false) })
  }

  trait DefaultRexcorexml_AggregatorFormat extends scalaxb.XMLFormat[rex.core.xml.Aggregator] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.Aggregator] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.Aggregator = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("SUM")) => rex.core.xml.SUM
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("MAX")) => rex.core.xml.MAX
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("MIN")) => rex.core.xml.MIN
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("COUNT")) => rex.core.xml.COUNT
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("AVG")) => rex.core.xml.AVG

    }

    def writes(__obj: rex.core.xml.Aggregator, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultRexcorexml_AggregationTypeFormat extends scalaxb.XMLFormat[rex.core.xml.AggregationType] with scalaxb.CanWriteChildNodes[rex.core.xml.AggregationType] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.AggregationType] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.AggregationType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@aggregator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.Aggregator](x, scalaxb.ElemName(node) :: stack)) } map {
            "@aggregator" -> _
          },
          (node \ "@alias").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
            "@alias" -> _
          },
          (node \ "@decimalPlaces").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map {
            "@decimalPlaces" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.AggregationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@aggregator", _) => attr = scala.xml.Attribute(null, "aggregator", __obj.aggregator.toString, attr)
        case ("@alias", _) => attr = scala.xml.Attribute(null, "alias", __obj.alias.toString, attr)
        case ("@decimalPlaces", _) => __obj.decimalPlaces foreach { x => attr = scala.xml.Attribute(null, "decimalPlaces", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.AggregationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultRexcorexml_RenameTypeFormat extends scalaxb.XMLFormat[rex.core.xml.RenameType] with scalaxb.CanWriteChildNodes[rex.core.xml.RenameType] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.RenameType] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.RenameType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@existingName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
            "@existingName" -> _
          },
          (node \ "@newName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
            "@newName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.RenameType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@existingName", _) => attr = scala.xml.Attribute(null, "existingName", __obj.existingName.toString, attr)
        case ("@newName", _) => attr = scala.xml.Attribute(null, "newName", __obj.newName.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.RenameType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultRexcorexml_ValueFromFormat extends scalaxb.XMLFormat[rex.core.xml.ValueFrom] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.ValueFrom] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.ValueFrom = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("literal")) => rex.core.xml.Literal
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("fromProperties")) => rex.core.xml.FromProperties
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("fromStandardEnvVariable")) => rex.core.xml.FromStandardEnvVariable

    }

    def writes(__obj: rex.core.xml.ValueFrom, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultRexcorexml_AddColumnTypeFormat extends scalaxb.XMLFormat[rex.core.xml.AddColumnType] with scalaxb.CanWriteChildNodes[rex.core.xml.AddColumnType] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.AddColumnType] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.AddColumnType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
            "@name" -> _
          },
          (node \ "@dataType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.ColumnDataType](x, scalaxb.ElemName(node) :: stack)) } map {
            "@dataType" -> _
          },
          (node \ "@valueFrom").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.ValueFrom](x, scalaxb.ElemName(node) :: stack)) } map {
            "@valueFrom" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.AddColumnType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@dataType", _) => __obj.dataType foreach { x => attr = scala.xml.Attribute(null, "dataType", x.toString, attr) }
        case ("@valueFrom", _) => attr = scala.xml.Attribute(null, "valueFrom", __obj.valueFrom.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.AddColumnType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultRexcorexml_ColumnTransformationTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.ColumnTransformationType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("ColumnTransformationType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.ColumnTransformationType] =
      phrase(opt(scalaxb.ElemName(None, "AddNew")) ~
        opt(scalaxb.ElemName(None, "Delete")) ~
        opt(scalaxb.ElemName(None, "Rename")) ^^ { case p1 ~ p2 ~ p3 =>
        rex.core.xml.ColumnTransformationType(p1.headOption map {
          scalaxb.fromXML[rex.core.xml.AddColumnsType](_, scalaxb.ElemName(node) :: stack)
        },
          p2.headOption map {
            scalaxb.fromXML[rex.core.xml.DeleteColumnType](_, scalaxb.ElemName(node) :: stack)
          },
          p3.headOption map {
            scalaxb.fromXML[rex.core.xml.RenamesType](_, scalaxb.ElemName(node) :: stack)
          }) })

    def writesChildNodes(__obj: rex.core.xml.ColumnTransformationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.AddNew map {
        scalaxb.toXML[rex.core.xml.AddColumnsType](_, None, Some("AddNew"), __scope, false)
      } getOrElse {
        Nil
      },
        __obj.Delete map {
          scalaxb.toXML[rex.core.xml.DeleteColumnType](_, None, Some("Delete"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Rename map {
          scalaxb.toXML[rex.core.xml.RenamesType](_, None, Some("Rename"), __scope, false)
        } getOrElse {
          Nil})

  }

  trait DefaultRexcorexml_DataFlowTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.DataFlowType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("DataFlowType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.DataFlowType] =
      phrase(safeRep(scalaxb.ElemName(None, "Flow")) ^^ { case p1 =>
        rex.core.xml.DataFlowType(p1 map {
          scalaxb.fromXML[rex.core.xml.FlowType](_, scalaxb.ElemName(node) :: stack)
        }) })

    def writesChildNodes(__obj: rex.core.xml.DataFlowType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Flow flatMap {
        scalaxb.toXML[rex.core.xml.FlowType](_, None, Some("Flow"), __scope, false) })
  }

  trait DefaultRexcorexml_TransformationsTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.TransformationsType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("TransformationsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.TransformationsType] =
      phrase(safeRep(scalaxb.ElemName(None, "Transformation")) ^^ { case p1 =>
        rex.core.xml.TransformationsType(p1 map {
          scalaxb.fromXML[rex.core.xml.TransformationType](_, scalaxb.ElemName(node) :: stack)
        }) })

    def writesChildNodes(__obj: rex.core.xml.TransformationsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Transformation flatMap {
        scalaxb.toXML[rex.core.xml.TransformationType](_, None, Some("Transformation"), __scope, false) })
  }

  trait DefaultRexcorexml_HiveTableTypeFormat extends scalaxb.XMLFormat[rex.core.xml.HiveTableType] with scalaxb.CanWriteChildNodes[rex.core.xml.HiveTableType] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.HiveTableType] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.HiveTableType(scala.collection.immutable.ListMap(List(
        (node \ "@tableName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@tableName" -> _
        }
      ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.HiveTableType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@tableName", _) => __obj.tableName foreach { x => attr = scala.xml.Attribute(null, "tableName", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.HiveTableType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultRexcorexml_TransCategoryFormat extends scalaxb.XMLFormat[rex.core.xml.TransCategory] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.TransCategory] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.TransCategory = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("SchemaTransformation")) => rex.core.xml.SchemaTransformation
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("ColumnTransformation")) => rex.core.xml.ColumnTransformation
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("GroupByTransformation")) => rex.core.xml.GroupByTransformation
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("SimpleFilterTransformation")) => rex.core.xml.SimpleFilterTransformation
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("CustomFilterTransformation")) => rex.core.xml.CustomFilterTransformation
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("CustomTransformation")) => rex.core.xml.CustomTransformation
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("JoinTransformation")) => rex.core.xml.JoinTransformation
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("SQLTransformation")) => rex.core.xml.SQLTransformation
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("DeDuplicationTransformation")) => rex.core.xml.DeDuplicationTransformation
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("ExpressionTransformation")) => rex.core.xml.ExpressionTransformation

    }

    def writes(__obj: rex.core.xml.TransCategory, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultRexcorexml_ExpressionFormat extends scalaxb.ElemNameParser[rex.core.xml.Expression] {
    val targetNamespace: Option[String] = None

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.Expression] =
      phrase(opt(scalaxb.ElemName(None, "RowExpression")) ~
        opt(scalaxb.ElemName(None, "ColumnExpression")) ~
        opt(scalaxb.ElemName(None, "FilterExpression")) ^^ { case p1 ~ p2 ~ p3 =>
        rex.core.xml.Expression(p1.headOption map {
          scalaxb.fromXML[rex.core.xml.ExpressionRowType](_, scalaxb.ElemName(node) :: stack)
        },
          p2.headOption map {
            scalaxb.fromXML[rex.core.xml.ExpressionColumnType](_, scalaxb.ElemName(node) :: stack)
          },
          p3.headOption map {
            scalaxb.fromXML[rex.core.xml.ExpressionFilterType](_, scalaxb.ElemName(node) :: stack)
          }) })

    def writesChildNodes(__obj: rex.core.xml.Expression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.RowExpression map {
        scalaxb.toXML[rex.core.xml.ExpressionRowType](_, None, Some("RowExpression"), __scope, false)
      } getOrElse {
        Nil
      },
        __obj.ColumnExpression map {
          scalaxb.toXML[rex.core.xml.ExpressionColumnType](_, None, Some("ColumnExpression"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.FilterExpression map {
          scalaxb.toXML[rex.core.xml.ExpressionFilterType](_, None, Some("FilterExpression"), __scope, false)
        } getOrElse {
          Nil})

  }

  trait DefaultRexcorexml_TransformationTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.TransformationType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("TransformationType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.TransformationType] =
      phrase(opt(scalaxb.ElemName(None, "ColumnTransformations")) ~
        opt(scalaxb.ElemName(None, "GroupByTransformation")) ~
        opt(scalaxb.ElemName(None, "JoinTransformation")) ~
        opt(scalaxb.ElemName(None, "DeDuplication")) ~
        opt(scalaxb.ElemName(None, "Expression")) ^^ { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
        rex.core.xml.TransformationType(p1.headOption map {
          scalaxb.fromXML[rex.core.xml.ColumnTransformationType](_, scalaxb.ElemName(node) :: stack)
        },
          p2.headOption map {
            scalaxb.fromXML[rex.core.xml.GroupByType](_, scalaxb.ElemName(node) :: stack)
          },
          p3.headOption map {
            scalaxb.fromXML[rex.core.xml.JoinTransformType](_, scalaxb.ElemName(node) :: stack)
          },
          p4.headOption map {
            scalaxb.fromXML[rex.core.xml.DeDuplicationType](_, scalaxb.ElemName(node) :: stack)
          },
          p5.headOption map {
            scalaxb.fromXML[rex.core.xml.Expression](_, scalaxb.ElemName(node) :: stack)
          },
          scala.collection.immutable.ListMap(List(
            (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@name" -> _
            },
            (node \ "@transCategory").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.TransCategory](x, scalaxb.ElemName(node) :: stack)) } map {
              "@transCategory" -> _
            },
            (node \ "@applyondataref").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@applyondataref" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.TransformationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@transCategory", _) => attr = scala.xml.Attribute(null, "transCategory", __obj.transCategory.toString, attr)
        case ("@applyondataref", _) => attr = scala.xml.Attribute(null, "applyondataref", __obj.applyondataref.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.TransformationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.ColumnTransformations map {
        scalaxb.toXML[rex.core.xml.ColumnTransformationType](_, None, Some("ColumnTransformations"), __scope, false)
      } getOrElse {
        Nil
      },
        __obj.GroupByTransformation map {
          scalaxb.toXML[rex.core.xml.GroupByType](_, None, Some("GroupByTransformation"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.JoinTransformation map {
          scalaxb.toXML[rex.core.xml.JoinTransformType](_, None, Some("JoinTransformation"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.DeDuplication map {
          scalaxb.toXML[rex.core.xml.DeDuplicationType](_, None, Some("DeDuplication"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Expression map {
          scalaxb.toXML[rex.core.xml.Expression](_, None, Some("Expression"), __scope, false)
        } getOrElse {
          Nil})

  }

  trait DefaultRexcorexml_ModeTypeFormat extends scalaxb.XMLFormat[rex.core.xml.ModeType] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.ModeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.ModeType = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Append")) => rex.core.xml.Append
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Overwrite")) => rex.core.xml.Overwrite
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("ErrorIfExists")) => rex.core.xml.ErrorIfExists
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Ignore")) => rex.core.xml.Ignore

    }

    def writes(__obj: rex.core.xml.ModeType, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultRexcorexml_DataSourcesTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.DataSourcesType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("DataSourcesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.DataSourcesType] =
      phrase(safeRep(scalaxb.ElemName(None, "DataSource")) ^^ { case p1 =>
        rex.core.xml.DataSourcesType(p1 map {
          scalaxb.fromXML[rex.core.xml.DataSourceType](_, scalaxb.ElemName(node) :: stack)
        }) })

    def writesChildNodes(__obj: rex.core.xml.DataSourcesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.DataSource flatMap {
        scalaxb.toXML[rex.core.xml.DataSourceType](_, None, Some("DataSource"), __scope, false) })
  }

  trait DefaultRexcorexml_DataSourceTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.DataSourceType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("DataSourceType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.DataSourceType] =
      phrase((((scalaxb.ElemName(None, "Database")) ^^
        (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rex.core.xml.DatabaseType](x, scalaxb.ElemName(node) :: stack)))) |
        ((scalaxb.ElemName(None, "File")) ^^
          (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rex.core.xml.FileType](x, scalaxb.ElemName(node) :: stack))))) ^^ { case p1 =>
        rex.core.xml.DataSourceType(p1,
          scala.collection.immutable.ListMap(List(
            (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.SourceType](x, scalaxb.ElemName(node) :: stack)) } map {
              "@type" -> _
            },
            (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@name" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.DataSourceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.DataSourceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.datasourcetypeoption) map { x => scalaxb.toXML[scalaxb.DataRecord[rex.core.xml.DataSourceTypeOption]](x, x.namespace, x.key, __scope, false) }).get)
  }

  trait DefaultRexcorexml_DatabaseTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.DatabaseType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("DatabaseType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.DatabaseType] =
      phrase((scalaxb.ElemName(None, "Query")) ~
        (scalaxb.ElemName(None, "Connection")) ^^ { case p1 ~ p2 =>
        rex.core.xml.DatabaseType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
          scalaxb.fromXML[String](p2, scalaxb.ElemName(node) :: stack)) })

    def writesChildNodes(__obj: rex.core.xml.DatabaseType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.Query, None, Some("Query"), __scope, false),
        scalaxb.toXML[String](__obj.Connection, None, Some("Connection"), __scope, false))

  }

  trait DefaultRexcorexml_FormatFormat extends scalaxb.XMLFormat[rex.core.xml.Format] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.Format] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.Format = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("csv")) => rex.core.xml.CsvValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("parquet")) => rex.core.xml.ParquetValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("orc")) => rex.core.xml.Orc
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("text")) => rex.core.xml.Text
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("json")) => rex.core.xml.JsonValue

    }

    def writes(__obj: rex.core.xml.Format, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultRexcorexml_FileTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.FileType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("FileType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.FileType] =
      phrase((scalaxb.ElemName(None, "DirectoryPath")) ~
        opt(scalaxb.ElemName(None, "FileNameOrPattern")) ~
        opt(scalaxb.ElemName(None, "TopLinesToIgnore")) ~
        opt(scalaxb.ElemName(None, "BottomLinesToIgnore")) ~
        opt(scalaxb.ElemName(None, "Quote")) ~
        opt(scalaxb.ElemName(None, "Delimiter")) ~
        opt(scalaxb.ElemName(None, "Header")) ~
        opt(scalaxb.ElemName(None, "SchemaFilePath")) ~
        opt(scalaxb.ElemName(None, "Schema")) ~
        opt(scalaxb.ElemName(None, "Tags")) ~
        safeRep(scalaxb.ElemName(None, "WithColumn")) ^^ { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 =>
        rex.core.xml.FileType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
          p2.headOption map {
            scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
          },
          p3.headOption map {
            scalaxb.fromXML[Int](_, scalaxb.ElemName(node) :: stack)
          },
          p4.headOption map {
            scalaxb.fromXML[Int](_, scalaxb.ElemName(node) :: stack)
          },
          p5.headOption map {
            scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
          },
          p6.headOption map {
            scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
          },
          p7.headOption map {
            scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack)
          },
          p8.headOption map {
            scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
          },
          p9.headOption map {
            scalaxb.fromXML[rex.core.xml.SchemaType](_, scalaxb.ElemName(node) :: stack)
          },
          p10.headOption map {
            scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
          },
          p11 map {
            scalaxb.fromXML[rex.core.xml.WithColumnType](_, scalaxb.ElemName(node) :: stack)
          },
          scala.collection.immutable.ListMap(List(
            (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@name" -> _
            },
            (node \ "@format").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.Format](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[rex.core.xml.Format](scala.xml.Text("csv"), scalaxb.ElemName(node) :: stack))) map {
              "@format" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.FileType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@format", _) => if (__obj.format.toString != "csv") attr = scala.xml.Attribute(null, "format", __obj.format.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.FileType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.DirectoryPath, None, Some("DirectoryPath"), __scope, false),
        __obj.FileNameOrPattern map {
          scalaxb.toXML[String](_, None, Some("FileNameOrPattern"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.TopLinesToIgnore map {
          scalaxb.toXML[Int](_, None, Some("TopLinesToIgnore"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.BottomLinesToIgnore map {
          scalaxb.toXML[Int](_, None, Some("BottomLinesToIgnore"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Quote map {
          scalaxb.toXML[String](_, None, Some("Quote"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Delimiter map {
          scalaxb.toXML[String](_, None, Some("Delimiter"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Header map {
          scalaxb.toXML[Boolean](_, None, Some("Header"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.SchemaFilePath map {
          scalaxb.toXML[String](_, None, Some("SchemaFilePath"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Schema map {
          scalaxb.toXML[rex.core.xml.SchemaType](_, None, Some("Schema"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Tags map {
          scalaxb.toXML[String](_, None, Some("Tags"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.WithColumn flatMap {
          scalaxb.toXML[rex.core.xml.WithColumnType](_, None, Some("WithColumn"), __scope, false) })

  }

  trait DefaultRexcorexml_WithColumnTypeFormat extends scalaxb.XMLFormat[rex.core.xml.WithColumnType] with scalaxb.CanWriteChildNodes[rex.core.xml.WithColumnType] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.WithColumnType] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.WithColumnType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
            "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.WithColumnType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.WithColumnType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultRexcorexml_PropertiesTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.PropertiesType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("PropertiesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.PropertiesType] =
      phrase(safeRep(scalaxb.ElemName(None, "Property")) ~
        opt(scalaxb.ElemName(None, "PropertyFilePath")) ^^ { case p1 ~ p2 =>
        rex.core.xml.PropertiesType(p1 map {
          scalaxb.fromXML[rex.core.xml.PropertyType](_, scalaxb.ElemName(node) :: stack)
        },
          p2.headOption map {
            scalaxb.fromXML[rex.core.xml.PropertyFilePathType](_, scalaxb.ElemName(node) :: stack)
          }) })

    def writesChildNodes(__obj: rex.core.xml.PropertiesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.Property flatMap {
        scalaxb.toXML[rex.core.xml.PropertyType](_, None, Some("Property"), __scope, false)
      },
        __obj.PropertyFilePath map {
          scalaxb.toXML[rex.core.xml.PropertyFilePathType](_, None, Some("PropertyFilePath"), __scope, false)
        } getOrElse {
          Nil})

  }

  trait DefaultRexcorexml_PropertyFilePathTypeFormat extends scalaxb.XMLFormat[rex.core.xml.PropertyFilePathType] with scalaxb.CanWriteChildNodes[rex.core.xml.PropertyFilePathType] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.PropertyFilePathType] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.PropertyFilePathType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@propertyWithPrefix").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
            "@propertyWithPrefix" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.PropertyFilePathType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@propertyWithPrefix", _) => __obj.propertyWithPrefix foreach { x => attr = scala.xml.Attribute(null, "propertyWithPrefix", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.PropertyFilePathType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultRexcorexml_PropertyTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.PropertyType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("PropertyType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.PropertyType] =
      phrase((scalaxb.ElemName(None, "Key")) ~
        (scalaxb.ElemName(None, "Value")) ^^ { case p1 ~ p2 =>
        rex.core.xml.PropertyType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
          scalaxb.fromXML[String](p2, scalaxb.ElemName(node) :: stack),
          scala.collection.immutable.ListMap(List(
            (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@name" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.PropertyType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.PropertyType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.Key, None, Some("Key"), __scope, false),
        scalaxb.toXML[String](__obj.Value, None, Some("Value"), __scope, false))

  }

  trait DefaultRexcorexml_IngestTypeFormat extends scalaxb.XMLFormat[rex.core.xml.IngestType] with scalaxb.CanWriteChildNodes[rex.core.xml.IngestType] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.IngestType] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.IngestType(scala.collection.immutable.ListMap(List(
        (node \ "@applyondataref").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@applyondataref" -> _
        },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@name" -> _
        }
      ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.IngestType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@applyondataref", _) => attr = scala.xml.Attribute(null, "applyondataref", __obj.applyondataref.toString, attr)
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.IngestType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultRexcorexml_SourceTypeFormat extends scalaxb.XMLFormat[rex.core.xml.SourceType] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.SourceType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.SourceType = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("file")) => rex.core.xml.File
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("db")) => rex.core.xml.Db

    }

    def writes(__obj: rex.core.xml.SourceType, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultRexcorexml_ReportingSqlFormat extends scalaxb.XMLFormat[rex.core.xml.ReportingSql] with scalaxb.CanWriteChildNodes[rex.core.xml.ReportingSql] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.ReportingSql] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.ReportingSql(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
            "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.ReportingSql, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.ReportingSql, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultRexcorexml_ReportingTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.ReportingType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("ReportingType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.ReportingType] =
      phrase(safeRep(scalaxb.ElemName(None, "ReportingSql")) ~
        (scalaxb.ElemName(None, "PublishTo")) ~
        (scalaxb.ElemName(None, "PublishingPath")) ~
        opt(scalaxb.ElemName(None, "Mode")) ^^ { case p1 ~ p2 ~ p3 ~ p4 =>
        rex.core.xml.ReportingType(p1 map {
          scalaxb.fromXML[rex.core.xml.ReportingSql](_, scalaxb.ElemName(node) :: stack)
        },
          scalaxb.fromXML[String](p2, scalaxb.ElemName(node) :: stack),
          scalaxb.fromXML[String](p3, scalaxb.ElemName(node) :: stack),
          p4.headOption map {
            scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
          },
          scala.collection.immutable.ListMap(List(
            (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@name" -> _
            },
            (node \ "@applyondataref").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@applyondataref" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.ReportingType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@applyondataref", _) => attr = scala.xml.Attribute(null, "applyondataref", __obj.applyondataref.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.ReportingType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.ReportingSql flatMap {
        scalaxb.toXML[rex.core.xml.ReportingSql](_, None, Some("ReportingSql"), __scope, false) },
        scalaxb.toXML[String](__obj.PublishTo, None, Some("PublishTo"), __scope, false),
        scalaxb.toXML[String](__obj.PublishingPath, None, Some("PublishingPath"), __scope, false),
        __obj.Mode map {
          scalaxb.toXML[String](_, None, Some("Mode"), __scope, false)
        } getOrElse {
          Nil})

  }

  trait DefaultRexcorexml_SideFormat extends scalaxb.XMLFormat[rex.core.xml.Side] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.Side] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.Side = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("source")) => rex.core.xml.Source
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("target")) => rex.core.xml.Target

    }

    def writes(__obj: rex.core.xml.Side, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultRexcorexml_StrategyFormat extends scalaxb.XMLFormat[rex.core.xml.Strategy] with scalaxb.CanWriteChildNodes[rex.core.xml.Strategy] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.Strategy] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.Strategy(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@columns").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
            "@columns" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.Strategy, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@columns", _) => __obj.columns foreach { x => attr = scala.xml.Attribute(null, "columns", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.Strategy, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultRexcorexml_DeDuplicationTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.DeDuplicationType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("DeDuplicationType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.DeDuplicationType] =
      phrase((scalaxb.ElemName(None, "DeDupColumns")) ~
        opt(scalaxb.ElemName(None, "Strategy")) ^^ { case p1 ~ p2 =>
        rex.core.xml.DeDuplicationType(scalaxb.fromXML[rex.core.xml.ColumnListType](p1, scalaxb.ElemName(node) :: stack),
          p2.headOption map {
            scalaxb.fromXML[rex.core.xml.Strategy](_, scalaxb.ElemName(node) :: stack)
          },
          scala.collection.immutable.ListMap(List(
            (node \ "@side").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.Side](x, scalaxb.ElemName(node) :: stack)) } map {
              "@side" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.DeDuplicationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@side", _) => __obj.side foreach { x => attr = scala.xml.Attribute(null, "side", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.DeDuplicationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rex.core.xml.ColumnListType](__obj.DeDupColumns, None, Some("DeDupColumns"), __scope, false),
        __obj.Strategy map {
          scalaxb.toXML[rex.core.xml.Strategy](_, None, Some("Strategy"), __scope, false)
        } getOrElse {
          Nil})

  }

  trait DefaultRexcorexml_DateColumnFormat extends scalaxb.XMLFormat[rex.core.xml.DateColumn] with scalaxb.CanWriteChildNodes[rex.core.xml.DateColumn] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.DateColumn] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.DateColumn(scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@name" -> _
        },
        (node \ "@sourceFormat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@sourceFormat" -> _
        },
        (node \ "@targetFormat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@targetFormat" -> _
        }
      ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.DateColumn, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@sourceFormat", _) => __obj.sourceFormat foreach { x => attr = scala.xml.Attribute(null, "sourceFormat", x.toString, attr) }
        case ("@targetFormat", _) => __obj.targetFormat foreach { x => attr = scala.xml.Attribute(null, "targetFormat", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.DateColumn, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultRexcorexml_DateColumnsTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.DateColumnsType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("DateColumnsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.DateColumnsType] =
      phrase(safeRep(scalaxb.ElemName(None, "DateColumn")) ^^ { case p1 =>
        rex.core.xml.DateColumnsType(p1 map {
          scalaxb.fromXML[rex.core.xml.DateColumn](_, scalaxb.ElemName(node) :: stack)
        }) })

    def writesChildNodes(__obj: rex.core.xml.DateColumnsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.DateColumn flatMap {
        scalaxb.toXML[rex.core.xml.DateColumn](_, None, Some("DateColumn"), __scope, false) })
  }

  trait DefaultRexcorexml_ModeFormat extends scalaxb.XMLFormat[rex.core.xml.Mode] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.Mode] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.Mode = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("required")) => rex.core.xml.Required
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("ignore")) => rex.core.xml.IgnoreValue

    }

    def writes(__obj: rex.core.xml.Mode, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultRexcorexml_SelectColumnsWithModeTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.SelectColumnsWithModeType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("SelectColumnsWithModeType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.SelectColumnsWithModeType] =
      phrase(safeRep(scalaxb.ElemName(None, "Column")) ^^ { case p1 =>
        rex.core.xml.SelectColumnsWithModeType(p1 map {
          scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
        },
          scala.collection.immutable.ListMap(List(
            (node \ "@mode").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.Mode](x, scalaxb.ElemName(node) :: stack)) } map {
              "@mode" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.SelectColumnsWithModeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@mode", _) => __obj.mode foreach { x => attr = scala.xml.Attribute(null, "mode", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.SelectColumnsWithModeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Column flatMap {
        scalaxb.toXML[String](_, None, Some("Column"), __scope, false) })
  }

  trait DefaultRexcorexml_ReconcilerTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.ReconcilerType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("ReconcilerType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.ReconcilerType] =
      phrase((scalaxb.ElemName(None, "ClassName")) ^^ { case p1 =>
        rex.core.xml.ReconcilerType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack)) })

    def writesChildNodes(__obj: rex.core.xml.ReconcilerType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[String](__obj.ClassName, None, Some("ClassName"), __scope, false))
  }

  trait DefaultRexcorexml_ReconciliationTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.ReconciliationType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("ReconciliationType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.ReconciliationType] =
      phrase((scalaxb.ElemName(None, "Source")) ~
        (scalaxb.ElemName(None, "Target")) ~
        (scalaxb.ElemName(None, "ComparisonKey")) ~
        opt(scalaxb.ElemName(None, "DateColumns")) ~
        opt(scalaxb.ElemName(None, "NumericColumns")) ~
        opt(scalaxb.ElemName(None, "ReconcileColumns")) ~
        opt(scalaxb.ElemName(None, "Reconciler")) ~
        opt(scalaxb.ElemName(None, "CaseColumns")) ~
        opt(scalaxb.ElemName(None, "AdditionalRequiredFields")) ~
        safeRep(scalaxb.ElemName(None, "DeDuplicationStrategy")) ^^ { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 =>
        rex.core.xml.ReconciliationType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
          scalaxb.fromXML[String](p2, scalaxb.ElemName(node) :: stack),
          scalaxb.fromXML[rex.core.xml.ColumnListType](p3, scalaxb.ElemName(node) :: stack),
          p4.headOption map {
            scalaxb.fromXML[rex.core.xml.DateColumnsType](_, scalaxb.ElemName(node) :: stack)
          },
          p5.headOption map {
            scalaxb.fromXML[rex.core.xml.ColumnListType](_, scalaxb.ElemName(node) :: stack)
          },
          p6.headOption map {
            scalaxb.fromXML[rex.core.xml.SelectColumnsWithModeType](_, scalaxb.ElemName(node) :: stack)
          },
          p7.headOption map {
            scalaxb.fromXML[rex.core.xml.ReconcilerType](_, scalaxb.ElemName(node) :: stack)
          },
          p8.headOption map {
            scalaxb.fromXML[rex.core.xml.SelectColumnsWithModeType](_, scalaxb.ElemName(node) :: stack)
          },
          p9.headOption map {
            scalaxb.fromXML[rex.core.xml.AdditionalFieldsType](_, scalaxb.ElemName(node) :: stack)
          },
          p10 map {
            scalaxb.fromXML[rex.core.xml.DeDuplicationType](_, scalaxb.ElemName(node) :: stack)
          },
          scala.collection.immutable.ListMap(List(
            (node \ "@applyondataref").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@applyondataref" -> _
            },
            (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@name" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.ReconciliationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@applyondataref", _) => attr = scala.xml.Attribute(null, "applyondataref", __obj.applyondataref.toString, attr)
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.ReconciliationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.Source, None, Some("Source"), __scope, false),
        scalaxb.toXML[String](__obj.Target, None, Some("Target"), __scope, false),
        scalaxb.toXML[rex.core.xml.ColumnListType](__obj.ComparisonKey, None, Some("ComparisonKey"), __scope, false),
        __obj.DateColumns map {
          scalaxb.toXML[rex.core.xml.DateColumnsType](_, None, Some("DateColumns"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.NumericColumns map {
          scalaxb.toXML[rex.core.xml.ColumnListType](_, None, Some("NumericColumns"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.ReconcileColumns map {
          scalaxb.toXML[rex.core.xml.SelectColumnsWithModeType](_, None, Some("ReconcileColumns"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.Reconciler map {
          scalaxb.toXML[rex.core.xml.ReconcilerType](_, None, Some("Reconciler"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.CaseColumns map {
          scalaxb.toXML[rex.core.xml.SelectColumnsWithModeType](_, None, Some("CaseColumns"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.AdditionalRequiredFields map {
          scalaxb.toXML[rex.core.xml.AdditionalFieldsType](_, None, Some("AdditionalRequiredFields"), __scope, false)
        } getOrElse {
          Nil
        },
        __obj.DeDuplicationStrategy flatMap {
          scalaxb.toXML[rex.core.xml.DeDuplicationType](_, None, Some("DeDuplicationStrategy"), __scope, false) })

  }

  trait DefaultRexcorexml_ExportTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.ExportType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("ExportType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.ExportType] =
      phrase(opt(((scalaxb.ElemName(None, "Hive")) ^^
        (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rex.core.xml.HiveTableType](x, scalaxb.ElemName(node) :: stack)))) |
        ((scalaxb.ElemName(None, "File")) ^^
          (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[rex.core.xml.ExportFileType](x, scalaxb.ElemName(node) :: stack))))) ^^ { case p1 =>
        rex.core.xml.ExportType(p1,
          scala.collection.immutable.ListMap(List(
            (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@name" -> _
            },
            (node \ "@applyondataref").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
              "@applyondataref" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.ExportType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@applyondataref", _) => attr = scala.xml.Attribute(null, "applyondataref", __obj.applyondataref.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.ExportType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.exporttypeoption map { x => scalaxb.toXML[scalaxb.DataRecord[rex.core.xml.ExportTypeOption]](x, x.namespace, x.key, __scope, false) } getOrElse {
        Nil})
  }

  trait DefaultRexcorexml_AdditionalFieldsTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.AdditionalFieldsType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("additionalFieldsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.AdditionalFieldsType] =
      phrase((scalaxb.ElemName(None, "source")) ~
        (scalaxb.ElemName(None, "target")) ^^ { case p1 ~ p2 =>
        rex.core.xml.AdditionalFieldsType(scalaxb.fromXML[rex.core.xml.ColumnListType](p1, scalaxb.ElemName(node) :: stack),
          scalaxb.fromXML[rex.core.xml.ColumnListType](p2, scalaxb.ElemName(node) :: stack)) })

    def writesChildNodes(__obj: rex.core.xml.AdditionalFieldsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[rex.core.xml.ColumnListType](__obj.source, None, Some("source"), __scope, false),
        scalaxb.toXML[rex.core.xml.ColumnListType](__obj.target, None, Some("target"), __scope, false))

  }

  trait DefaultRexcorexml_ColumnFormat extends scalaxb.XMLFormat[rex.core.xml.Column] with scalaxb.CanWriteChildNodes[rex.core.xml.Column] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.Column] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.Column(scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@name" -> _
        },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@type" -> _
        },
        (node \ "@isNullable").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map {
          "@isNullable" -> _
        },
        (node \ "@isNew").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map {
          "@isNew" -> _
        },
        (node \ "@expr").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@expr" -> _
        }
      ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.Column, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case ("@isNullable", _) => __obj.isNullable foreach { x => attr = scala.xml.Attribute(null, "isNullable", x.toString, attr) }
        case ("@isNew", _) => __obj.isNew foreach { x => attr = scala.xml.Attribute(null, "isNew", x.toString, attr) }
        case ("@expr", _) => attr = scala.xml.Attribute(null, "expr", __obj.expr.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.Column, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultRexcorexml_ExpressionColumnTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.ExpressionColumnType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("ExpressionColumnType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.ExpressionColumnType] =
      phrase(safeRep(scalaxb.ElemName(None, "Column")) ^^ { case p1 =>
        rex.core.xml.ExpressionColumnType(p1 map {
          scalaxb.fromXML[rex.core.xml.Column](_, scalaxb.ElemName(node) :: stack)
        }) })

    def writesChildNodes(__obj: rex.core.xml.ExpressionColumnType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.Column flatMap {
        scalaxb.toXML[rex.core.xml.Column](_, None, Some("Column"), __scope, false) })
  }

  trait DefaultRexcorexml_Column2Format extends scalaxb.XMLFormat[rex.core.xml.Column2] with scalaxb.CanWriteChildNodes[rex.core.xml.Column2] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.Column2] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.Column2(scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@name" -> _
        },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@type" -> _
        },
        (node \ "@isNullable").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map {
          "@isNullable" -> _
        },
        (node \ "@isNew").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map {
          "@isNew" -> _
        }
      ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.Column2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case ("@isNullable", _) => __obj.isNullable foreach { x => attr = scala.xml.Attribute(null, "isNullable", x.toString, attr) }
        case ("@isNew", _) => __obj.isNew foreach { x => attr = scala.xml.Attribute(null, "isNew", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.Column2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultRexcorexml_ExpressionRowTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.ExpressionRowType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("ExpressionRowType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.ExpressionRowType] =
      phrase(safeRep(scalaxb.ElemName(None, "Column")) ~
        (scalaxb.ElemName(None, "Expr")) ^^ { case p1 ~ p2 =>
        rex.core.xml.ExpressionRowType(p1 map {
          scalaxb.fromXML[rex.core.xml.Column2](_, scalaxb.ElemName(node) :: stack)
        },
          scalaxb.fromXML[String](p2, scalaxb.ElemName(node) :: stack)) })

    def writesChildNodes(__obj: rex.core.xml.ExpressionRowType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.Column flatMap {
        scalaxb.toXML[rex.core.xml.Column2](_, None, Some("Column"), __scope, false) },
        scalaxb.toXML[String](__obj.Expr, None, Some("Expr"), __scope, false))

  }

  trait DefaultRexcorexml_ExpressionFilterTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.ExpressionFilterType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("ExpressionFilterType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.ExpressionFilterType] =
      phrase((scalaxb.ElemName(None, "Expr")) ^^ { case p1 =>
        rex.core.xml.ExpressionFilterType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack)) })

    def writesChildNodes(__obj: rex.core.xml.ExpressionFilterType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[String](__obj.Expr, None, Some("Expr"), __scope, false))
  }

  trait DefaultRexcorexml_SchemaColumnTypeFormat extends scalaxb.XMLFormat[rex.core.xml.SchemaColumnType] with scalaxb.CanWriteChildNodes[rex.core.xml.SchemaColumnType] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.SchemaColumnType] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.SchemaColumnType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
          (node \ "@dataType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.ColumnDataType](x, scalaxb.ElemName(node) :: stack)) } map {
            "@dataType" -> _
          },
          (node \ "@isNullable").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map {
            "@isNullable" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.SchemaColumnType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@dataType", _) => __obj.dataType foreach { x => attr = scala.xml.Attribute(null, "dataType", x.toString, attr) }
        case ("@isNullable", _) => __obj.isNullable foreach { x => attr = scala.xml.Attribute(null, "isNullable", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.SchemaColumnType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultRexcorexml_EnforceModeFormat extends scalaxb.XMLFormat[rex.core.xml.EnforceMode] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.EnforceMode] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.EnforceMode = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("failFast")) => rex.core.xml.FailFast
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("dropMalformed")) => rex.core.xml.DropMalformed
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("permissive")) => rex.core.xml.Permissive

    }

    def writes(__obj: rex.core.xml.EnforceMode, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultRexcorexml_SchemaTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.SchemaType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("SchemaType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.SchemaType] =
      phrase(safeRep(scalaxb.ElemName(None, "SchemaColumn")) ^^ { case p1 =>
        rex.core.xml.SchemaType(p1 map {
          scalaxb.fromXML[rex.core.xml.SchemaColumnType](_, scalaxb.ElemName(node) :: stack)
        },
          scala.collection.immutable.ListMap(List(
            (node \ "@enforceMode").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.EnforceMode](x, scalaxb.ElemName(node) :: stack)) } map {
              "@enforceMode" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.SchemaType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@enforceMode", _) => __obj.enforceMode foreach { x => attr = scala.xml.Attribute(null, "enforceMode", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.SchemaType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.SchemaColumn flatMap {
        scalaxb.toXML[rex.core.xml.SchemaColumnType](_, None, Some("SchemaColumn"), __scope, false) })
  }

  trait DefaultRexcorexml_JoinTypeFormat extends scalaxb.XMLFormat[rex.core.xml.JoinType] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.JoinType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.JoinType = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("inner")) => rex.core.xml.Inner
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("full")) => rex.core.xml.Full
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => rex.core.xml.LeftType
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => rex.core.xml.RightType

    }

    def writes(__obj: rex.core.xml.JoinType, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultRexcorexml_JoinKeyFormat extends scalaxb.XMLFormat[rex.core.xml.JoinKey] with scalaxb.CanWriteChildNodes[rex.core.xml.JoinKey] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.JoinKey] = seq match {
      case node: scala.xml.Node => Right(rex.core.xml.JoinKey(scala.collection.immutable.ListMap(List(
        (node \ "@leftSideKey").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@leftSideKey" -> _
        },
        (node \ "@rightSideKey").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map {
          "@rightSideKey" -> _
        }
      ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }

    override def writesAttribute(__obj: rex.core.xml.JoinKey, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@leftSideKey", _) => attr = scala.xml.Attribute(null, "leftSideKey", __obj.leftSideKey.toString, attr)
        case ("@rightSideKey", _) => attr = scala.xml.Attribute(null, "rightSideKey", __obj.rightSideKey.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.JoinKey, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultRexcorexml_JoinTransformTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.JoinTransformType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("JoinTransformType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.JoinTransformType] =
      phrase((scalaxb.ElemName(None, "RightSideJoiningData")) ~
        (scalaxb.ElemName(None, "JoinKey")) ~
        opt(scalaxb.ElemName(None, "Select")) ^^ { case p1 ~ p2 ~ p3 =>
        rex.core.xml.JoinTransformType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
          scalaxb.fromXML[rex.core.xml.JoinKey](p2, scalaxb.ElemName(node) :: stack),
          p3.headOption map {
            scalaxb.fromXML[rex.core.xml.ColumnListType](_, scalaxb.ElemName(node) :: stack)
          },
          scala.collection.immutable.ListMap(List(
            (node \ "@joinType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[rex.core.xml.JoinType](x, scalaxb.ElemName(node) :: stack)) } map {
              "@joinType" -> _
            }
          ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })

    override def writesAttribute(__obj: rex.core.xml.JoinTransformType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData = scala.xml.Null
      __obj.attributes.toList map {
        case ("@joinType", _) => attr = scala.xml.Attribute(null, "joinType", __obj.joinType.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map {
          __scope.getPrefix(_)
        }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: rex.core.xml.JoinTransformType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.RightSideJoiningData, None, Some("RightSideJoiningData"), __scope, false),
        scalaxb.toXML[rex.core.xml.JoinKey](__obj.JoinKey, None, Some("JoinKey"), __scope, false),
        __obj.Select map {
          scalaxb.toXML[rex.core.xml.ColumnListType](_, None, Some("Select"), __scope, false)
        } getOrElse {
          Nil})

  }

  trait DefaultRexcorexml_ColumnDataTypeFormat extends scalaxb.XMLFormat[rex.core.xml.ColumnDataType] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.ColumnDataType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.ColumnDataType = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("integerType")) => rex.core.xml.IntegerType
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stringType")) => rex.core.xml.StringType
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("doubleType")) => rex.core.xml.DoubleType

    }

    def writes(__obj: rex.core.xml.ColumnDataType, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultRexcorexml_ExportFormatFormat extends scalaxb.XMLFormat[rex.core.xml.ExportFormat] {
    val targetNamespace: Option[String] = None

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, rex.core.xml.ExportFormat] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }

    def fromString(value: String, scope: scala.xml.NamespaceBinding): rex.core.xml.ExportFormat = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("csv")) => rex.core.xml.Csv
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("parquet")) => rex.core.xml.Parquet
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("avro")) => rex.core.xml.Avro
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("json")) => rex.core.xml.Json

    }

    def writes(__obj: rex.core.xml.ExportFormat, __namespace: Option[String], __elementLabel: Option[String],
               __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse {
          sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultRexcorexml_PartitionTypeFormat extends scalaxb.ElemNameParser[rex.core.xml.PartitionType] {
    val targetNamespace: Option[String] = None

    override def typeName: Option[String] = Some("PartitionType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[rex.core.xml.PartitionType] =
      phrase(opt(scalaxb.ElemName(None, "DatePartitionFormat")) ~
        opt(scalaxb.ElemName(None, "ColumnPartition")) ^^ { case p1 ~ p2 =>
        rex.core.xml.PartitionType(p1.headOption map {
          scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack)
        },
          p2.headOption map {
            scalaxb.fromXML[rex.core.xml.ColumnListType](_, scalaxb.ElemName(node) :: stack)
          }) })
    
    def writesChildNodes(__obj: rex.core.xml.PartitionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.DatePartitionFormat map {
        scalaxb.toXML[String](_, None, Some("DatePartitionFormat"), __scope, false)
      } getOrElse {
        Nil
      },
        __obj.ColumnPartition map {
          scalaxb.toXML[rex.core.xml.ColumnListType](_, None, Some("ColumnPartition"), __scope, false)
        } getOrElse {
          Nil})

  }


}

